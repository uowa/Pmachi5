#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('pmachi5:server');
var http = require('http');


/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * ADDED!! Require Socket.IO
 */
var io = require('socket.io')(server);


/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);



/**
 * ADDED!! Socket.IO Connection.
 */

let user = {};
// user={socketID:{userName,msg,socketID,room,AX,AY,DIR}};

let users = { "entrance": 0, "utyu": 0 };

var crypto = require("crypto");
// var cipers = crypto.getCiphers();
// console.log(cipers);
// var hashes = crypto.getHashes();
// console.log(hashes);

function tripCreate(isTrip) {
  let tripkey = isTrip;
  let salt = tripkey + "H.";//未入力、又は1文字入れ用にH.を追加？？
  salt = salt.substr(1, 2);//2文字目と3文字目を切り出す
  salt = salt.replace(/[^.-z]/g, ".");
  salt = salt.replace(/:/g, "A");
  salt = salt.replace(/;/g, "B");
  salt = salt.replace(/</g, "C");
  salt = salt.replace(/=/g, "D");
  salt = salt.replace(/>/g, "E");
  salt = salt.replace(/\?/g, "F");
  salt = salt.replace(/@/g, "G");
  salt = salt.replace(/\[/g, "a");
  salt = salt.replace(/\\/g, "b");
  salt = salt.replace(/]/g, "c");
  salt = salt.replace(/\^/g, "d");
  salt = salt.replace(/_/g, "e");
  salt = salt.replace(/`/g, "f");
  let cipher = crypto.createCipher("des", salt);
  cipher.update(tripkey, 'utf-8', 'base64');
  let cipheredText = cipher.final('base64');
  let trip = cipheredText.substr(-10);
  trip = trip.replace(/=/g, "");//なんかよくわからんけど、高確率で後ろに==が付くので消す
  trip = "◆" + trip;
  return trip;
}

let msgSE = {};
msgSE.login = {};
msgSE.login.in = new Array(0);
msgSE.login.logout = new Array(0);
msgSE.other = {};
msgSE.other.in = new Array(1);
msgSE.other.log = new Array(3);
msgSE.other.out = new Array(3);
msgSE.other.logout = new Array(1);
msgSE.utyu = {};
msgSE.utyu.in = new Array(1);
msgSE.utyu.log = new Array(4);
msgSE.utyu.out = new Array(1);
msgSE.utyu.logout = new Array(1);

let oekaki = {};
oekaki["loginBack"] = {};
oekaki["loginBack"].X = [];
oekaki["loginBack"].Y = [];
oekaki["entrance"] = {};
oekaki["entrance"].X = [];
oekaki["entrance"].Y = [];
oekaki["utyu"] = {};
oekaki["utyu"].X = [];
oekaki["utyu"].Y = [];

function volumeRandom(room, move) {
  let random;
  if (room = "entrance") {//※部屋数が増えたら||で継ぎ足す
    random = Math.floor(Math.random() * msgSE.other[move].length);
  } else {
    random = Math.floor(Math.random() * msgSE[room][move].length);
  }
  return random;
}

io.on('connection', function (socket) {
  //フォント切り替え
  function saikiMsg() {
    io.to(socket.id).json.emit("emitSaikiMsg", {
      msg: "ブラウザを更新してください",
    });
  }


  user[socket.id] = {
    userName: "名もなき名無し",
    AX: 457,
    AY: 80,
    DIR: "S",
    msg: "",
    avatar: "gomaneco",
    room: "loginBack",
  }


  socket.on("getMySocketID", function () {//ソケットIDを送る
    io.to(socket.id).json.emit("mySocketID", {
      socketID: socket.id,
    });
  });

  socket.on("login_room", function (data) {//ログイン処理
    if (user[socket.id] && data.userName.length < 28) {//サバ再起動前に開かれていたクライアントからの入力を阻止する。&&名前が２８
      //トリップを作る
      data.userName = data.userName.replace(/◆/g, '□');
      if (data.userName.match(/#/)) {
        let index = data.userName.indexOf("#");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }
      if (data.userName.match(/＃/)) {
        let index = data.userName.indexOf("＃");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }

      user[socket.id].userName = data.userName;//名前をサバに保存
      user[socket.id].avatar = data.avatar;//アバターを設定
      user[socket.id].avatarColor = data.avatarColor;//アバターの色を設定
      user[socket.id].avatarAlpha = data.avatarAlpha;//アバターの透明度を設定

      user[socket.id].room = data.room;//ユーザー情報に部屋を入れる
      users[data.room]++;//部屋人数を変更
      socket.join("entrance");



      time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";//入室時の時間


      socket.broadcast.emit("loadAvatar", {//全体に新規入場者を読みこます、後々全体人数もここで管理していいかな
        socketID: socket.id,
        avatar: data.avatar,
        userName: user[socket.id].userName,
        avatarColor: user[socket.id].avatarColor,
        avatarAlpha: user[socket.id].avatarAlpha,
      });

      io.to(socket.id).json.emit("roomInSelf", {
        beforeRoom: "login",
        user: user,
        room: "entrance",
        users: users[data.room],
        msg: user[socket.id].userName + "が" + data.room + "に入室しました。" + time,
        roomSE: "login",
        random: volumeRandom("login", "in"),
        oekakiX: oekaki[user[socket.id].room].X,
        oekakiY: oekaki[user[socket.id].room].Y,
      });

      socket.broadcast.to(data.room).emit("roomInNonSelf", {
        room: "entrance",
        socketID: socket.id,
        msg: user[socket.id].userName + "が" + data.room + "に入室しました。" + time,
        users: users[data.room],
        AX: 457,
        AY: 80,
        DIR: "S",
        roomSE: "login",
        random: volumeRandom("login", "in"),
      });
    } else {
      saikiMsg();//再起動メッセージを送る
    }
  });

  socket.on("roomIn", function (data) {
    if (user[data.socketID]) {////サバ再起動前に開かれていたクライアントからの入力を阻止する。
      time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";//入室時の時間
      let before = data.beforeRoom;
      let after = data.afterRoom;
      socket.leave(before);
      socket.join(after);
      users[before]--//入室前の部屋人数を減らす
      users[after]++;//入室後の部屋人数を増やす

      user[data.socketID].room = data.afterRoom;
      user[data.socketID].AX = data.AX;
      user[data.socketID].AY = data.AY;
      user[data.socketID].DIR = data.DIR;
      user[data.socketID].msg = "";

      io.to(socket.id).json.emit("roomInSelf", {
        user: user,
        room: data.afterRoom,
        msg: user[socket.id].userName + "が" + data.beforeRoom + "から移動してきました。" + time,
        users: users[after],
        roomSE: data.afterRoom,
        random: volumeRandom(data.afterRoom, "in"),
        oekakiX: oekaki[user[socket.id].room].X,
        oekakiY: oekaki[user[socket.id].room].Y,
      });

      socket.broadcast.to(after).emit("roomInNonSelf", {
        socketID: data.socketID,
        room: data.afterRoom,
        msg: user[data.socketID].userName + "が" + data.beforeRoom + "から移動してきました。" + time,
        users: users[data.afterRoom],
        AX: data.AX,
        AY: data.AY,
        DIR: data.DIR,
        roomSE: data.afterRoom,
        random: volumeRandom(data.afterRoom, "in"),
      });
      socket.broadcast.to(before).emit("roomOutNonSelf", {
        room: data.afterRoom,
        random: volumeRandom(data.beforeRoom, "out"),
      });
    } else {
      saikiMsg();
    }
  });



  //クライアントからメッセージを受け取って送信
  socket.on("emit_msg", function (data) {
    if (user[socket.id] && data.msg.length < 251) {//サバ再起動前に開かれていたクライアントからの入力を阻止する。
      if (data.kanban) {
        user[socket.id].msg = data.msg;

        //最後に発言したkanbanをuserの最後に入れなおす
        let value = user[socket.id];
        delete user[socket.id];
        user[socket.id] = value;
      } else {//kanbanじゃないなら、userのメッセージ情報は消しとく
        user[socket.id].msg = "";
      }

      io.to(user[socket.id].room).emit("emit_msg", {
        userName: user[socket.id].userName,
        msg: data.msg,
        socketID: socket.id,
        avaMsg: data.msg,
        abonClass: user[socket.id].socketID,//あとで考える！！！！！！！！！
        kanban: data.kanban,
        random: volumeRandom(user[socket.id].room, "log"),
      });
    } else {
      saikiMsg();
    }
  });

  //アボンの時
  socket.on("abonSetting", function (data) {
    if (user[data.socketID]) {//サバ再起動前に開かれていたクライアントからの入力を阻止する。
      let abonMsg;
      let abonAvaMsg;
      if (user[data.socketID] == null) {
        abonMsg = "その住民は退出済みです";
      } else if (data.setAbon) {
        abonMsg = user[data.socketID].userName + "をアボンしました。";
        abonAvaMsg = "アボン";//吹き出しをアボンにする。
      } else {
        abonMsg = user[data.socketID].userName + "のあぼんをやめました";
        abonAvaMsg = "";
      }
      io.to(socket.id).json.emit("abonSetting", {
        msg: abonMsg,
        socketID: data.socketID,
        avaMsg: abonAvaMsg,
        AX: user[data.socketID].AX,
        AY: user[data.socketID].AY,
        DIR: user[data.socketID].DIR,
      });
    } else {
      saikiMsg();//再起動メッセージを送る
    }
  });



  //クリックイベント
  socket.on('tapMap', function (data) {
    if (user[socket.id]) {//サバ再起動前に開かれていたクライアントからの入力を阻止する。
      user[socket.id].DIR = data.DIR;
      user[socket.id].AX = data.AX;
      user[socket.id].AY = data.AY;

      socket.broadcast.to(user[socket.id].room).emit("tapMap", {
        DIR: data.DIR,
        socketID: socket.id,
        AX: data.AX,
        AY: data.AY,
      });
    } else {
      saikiMsg();//再起動メッセージを送る
    }
  });

  socket.on("alphaChange", function (data) {
    user[socket.id].avatarAlpha = data.alpha;//アバターの透明度を設定
    socket.broadcast.emit("alphaChange", {
      socketID: socket.id,
      alpha: data.alpha,
    });
  });



  socket.on("oekaki", function (data) {
      oekaki[user[socket.id].room].X.push(data.oekakiX);
      oekaki[user[socket.id].room].Y.push(data.oekakiY);
    io.to(user[socket.id].room).emit("oekaki", {
      oekakiX: data.oekakiX,
      oekakiY: data.oekakiY,
    });
  });
  socket.on("clearCanvas", function (data) {
    oekaki[user[socket.id].room].X = [];
    oekaki[user[socket.id].room].Y = [];
    io.to(user[socket.id].room).emit("clearCanvas", {
    });
  });


  //退出時
  socket.on("disconnect", function () {
    users[user[socket.id].room]--;

    time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";

    io.to(user[socket.id].room).emit("logout", {
      socketID: socket.id,
      msg: user[socket.id].userName + "が退出しました。" + time,
      room: user[socket.id].room,
      users: users[user[socket.id].room],
      random: volumeRandom(user[socket.id].room, "logout"),
    });
    delete user[socket.id];

  });
});


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
